---
title: 线索化二叉树
date: 2025-11-19 17:30:47 +0800
categories: [CS]
tags: [data structure]
author: lihus
---

二叉树是每个节点最多有两个子节点的树结构，代码实现的节点对象除了自身数据外还会包含指向两个子节点的指针。
节点类的实现是统一的，所有节点对象都包含两个指针位，而二叉树的叶没有子节点，它们的这两个指针位是被空着的。
除此之外，其他节点也会出现只有一个子节点的情况。

## 先序、中序、后序

为了充分利用内存空间，可以将这些空指针改为指向另外节点的指针，称这个操作为线索化，具体指向的节点可以自由设置。
通过一定方式的线索化可以提高二叉树的遍历效率，遍历方式有**先序、中序、后序**三种，默认采用中序。

如何理解这三种遍历顺序呢？一开始，我看了几篇文章都没懂。当我抛开这些文章里的图示，从计算机的角度、编写代码的角度看，
事情便清晰了许多。试想编写结点的结构体，代码应如下：

```C
struct Node{
    Node* left;
    int data;
    Node* right;
};
```

那么当我们得到一个Node，在内存空间里，Node的三个成员的排列方式一般和数组 `{left,data,right}` 一样，
很自然地，我们会从左向右读。当读到left和right时，我们得到的都是一个Node对象（的指针）。我们不可能只读它们的值，
因为它们之下可能还有ChildNode。从代码角度看，最简洁的方式就是递归，将left和right传入读取函数中，这样就能遍历所有子树。
只需将根结点传入读取函数，就能遍历整棵树。

按读取先后顺序排列，就是**中序**。中序的*中*意思是读取本节点的步骤在读取左节点和右节点的步骤之间。这样先序和后序也就好理解了，
只是递归时把读取本节点的步骤放在了最前面或者最后面。

## 线索化

按中序方式遍历，若一个节点恰好在另一个节点之前先被遍历到，先被遍历到的节点就是另外这个节点的前驱，反之为后继。前面说到，对子节点数小于2的节点可以将它们的空指针改为指向另外节点的指针。我们知道，在中序下，若一个节点有左节点和右节点，那么左节点是其前驱，而右节点是它的后继。对于左节点指针为空的节点，我们可以将左指针设置为它的前驱，右节点对应设为其后继。我们用ltag和rtag区分指针
指向的是child还是前驱/后继节点。比如，若`ltag=0`，则左指针指向其lchild；若`ltag=1`，则左指针指向其前驱，或为nullptr（若它是中序首位）。

线索化后的二叉树可以高效进行非递归遍历：

```C++
void InOrderTraverse(Ttree Thrt) {
Ttree p = Thrt->lchild; // 从根结点开始
while (p != Thrt) {
while (p->LTag == 0) p = p->lchild; // 找到最左结点
cout << p->data << " "; // 输出当前结点
while (p->RTag == 1 && p->rchild != Thrt) {
p = p->rchild; // 访问后继结点
cout << p->data << " ";
}
p = p->rchild; // 转向右子树
}
}
```



遍历效率提高的关键，正在于指针指向前驱/后继的一致性。